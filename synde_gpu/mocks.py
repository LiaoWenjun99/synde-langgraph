"""
Mock GPU responses for testing without actual GPU.

Provides realistic mock responses for all GPU tasks to enable
testing the LangGraph workflow without requiring GPU resources.
"""

import os
import random
from typing import Any, Dict, Optional
from datetime import datetime

from synde_graph.config import MOCK_GPU


def is_mock_mode() -> bool:
    """Check if mock mode is enabled."""
    return MOCK_GPU or os.getenv("MOCK_GPU", "false").lower() in ("true", "1", "yes")


class MockGpuResponses:
    """Mock responses for GPU tasks."""

    # Sample PDB content for structure predictions
    SAMPLE_PDB = """HEADER    MOCK PROTEIN STRUCTURE
TITLE     GENERATED BY SYNDE-LANGGRAPH MOCK
ATOM      1  N   MET A   1       0.000   0.000   0.000  1.00 80.00           N
ATOM      2  CA  MET A   1       1.458   0.000   0.000  1.00 80.00           C
ATOM      3  C   MET A   1       2.009   1.420   0.000  1.00 80.00           C
ATOM      4  O   MET A   1       1.251   2.400   0.000  1.00 80.00           O
ATOM      5  CB  MET A   1       1.987  -0.769   1.223  1.00 80.00           C
ATOM      6  N   LYS A   2       3.288   1.515   0.346  1.00 82.00           N
ATOM      7  CA  LYS A   2       3.938   2.816   0.440  1.00 82.00           C
ATOM      8  C   LYS A   2       3.558   3.699  -0.752  1.00 82.00           C
ATOM      9  O   LYS A   2       3.831   4.896  -0.734  1.00 82.00           O
ATOM     10  CB  LYS A   2       5.459   2.660   0.491  1.00 82.00           C
END
"""

    @staticmethod
    def esmfold(job_id: str, sequence: str) -> Dict[str, Any]:
        """Mock ESMFold response."""
        # Generate realistic pLDDT based on sequence length
        avg_plddt = 75.0 + random.uniform(-10, 15)
        avg_plddt = min(95.0, max(50.0, avg_plddt))

        return {
            "status": "success",
            "pdb_path": f"/mock/esmfold/{job_id}.pdb",
            "pdb_data": MockGpuResponses.SAMPLE_PDB,
            "avg_plddt": round(avg_plddt, 2),
            "runtime_sec": round(random.uniform(5, 30), 1),
        }

    @staticmethod
    def clean_ec(sequence: str, seq_name: str = "Input_Seq") -> Dict[str, Any]:
        """Mock CLEAN EC number prediction response."""
        # Common EC numbers for enzymes
        ec_numbers = [
            "3.1.1.3",   # Lipase
            "2.7.1.1",   # Hexokinase
            "1.1.1.1",   # Alcohol dehydrogenase
            "3.4.21.4",  # Trypsin
            "2.6.1.1",   # Aspartate aminotransferase
            "4.2.1.1",   # Carbonic anhydrase
        ]
        ec = random.choice(ec_numbers)
        prob = 0.85 + random.uniform(0, 0.14)

        return {
            "status": "success",
            "ec_number": ec,
            "probability": round(prob, 4),
            "runtime_sec": round(random.uniform(2, 10), 1),
        }

    @staticmethod
    def deepenzyme(sequence: str, pdb_path: str, smiles: str) -> Dict[str, Any]:
        """Mock DeepEnzyme kcat prediction response."""
        # kcat values typically range from 0.1 to 10000 s^-1
        log_kcat = random.uniform(-1, 4)  # log10(kcat)
        kcat = round(10 ** log_kcat, 2)

        return {
            "status": "success",
            "kcat": kcat,
            "log_kcat": round(log_kcat, 3),
            "runtime_sec": round(random.uniform(5, 20), 1),
        }

    @staticmethod
    def temberture(sequence: str) -> Dict[str, Any]:
        """Mock TemBERTure melting temperature prediction response."""
        # Tm values typically range from 30 to 90 C
        tm = 55.0 + random.uniform(-20, 30)

        # Classify thermophilicity
        if tm > 70:
            thermo_class = "thermophilic"
        elif tm > 50:
            thermo_class = "mesophilic"
        else:
            thermo_class = "psychrophilic"

        return {
            "status": "success",
            "melting_temperature": round(tm, 2),
            "thermo_class": thermo_class,
            "runtime_sec": round(random.uniform(2, 8), 1),
        }

    @staticmethod
    def flan_extractor(query: str) -> tuple:
        """Mock FLAN NLP extraction response."""
        # Parse query for keywords
        query_lower = query.lower()

        # Detect task type
        if any(w in query_lower for w in ["generate", "design", "create", "optimize"]):
            task = "generation"
        elif any(w in query_lower for w in ["mutant", "mutation", "mutate"]):
            task = "mutagenesis"
        else:
            task = "prediction"

        # Detect properties
        properties = []
        if any(w in query_lower for w in ["stability", "stable", "stabilize"]):
            properties.append("stability")
        if any(w in query_lower for w in ["kcat", "catalytic", "activity"]):
            properties.append("kcat")
        if any(w in query_lower for w in ["ec", "enzyme class", "function"]):
            properties.append("ec_number")
        if any(w in query_lower for w in ["temperature", "tm", "melting", "thermal"]):
            properties.append("tm")
        if any(w in query_lower for w in ["topt", "optimum temperature"]):
            properties.append("topt")

        # Default to stability if no properties detected
        if not properties:
            properties = ["stability"]

        # Detect UniProt IDs (pattern: letter + 5 alphanumeric)
        import re
        uniprot_pattern = r'\b[A-Z][0-9A-Z]{5}\b'
        uniprot_ids = re.findall(uniprot_pattern, query)

        # Detect sequences (30+ uppercase letters)
        seq_pattern = r'[A-Z]{30,}'
        sequences = re.findall(seq_pattern, query.replace(" ", ""))
        protein_sequence = sequences[0] if sequences else None

        # Detect common ligands
        ligand = None
        common_ligands = ["atp", "adp", "nadh", "nad+", "fad", "glucose", "pyruvate"]
        for lig in common_ligands:
            if lig in query_lower:
                ligand = lig.upper()
                break

        return (
            task,
            properties,
            [],  # region
            uniprot_ids,
            protein_sequence,
            ligand,
            [],  # organism
        )

    @staticmethod
    def fpocket(pdb_path: str, output_dir: str, num_pockets: int = 5) -> Dict[str, Any]:
        """Mock Fpocket pocket detection response."""
        pockets = []
        pocket_residues = {}

        for i in range(num_pockets):
            score = 0.8 - (i * 0.1) + random.uniform(-0.05, 0.05)
            score = max(0.1, min(1.0, score))

            pocket = {
                "pocket_id": i + 1,
                "score": round(score, 3),
                "druggability_score": round(score * 0.9, 3),
                "volume": round(random.uniform(100, 500), 1),
            }
            pockets.append(pocket)

            # Generate mock residues
            start_res = random.randint(10, 200)
            residues = [f"A:{start_res + j}" for j in range(random.randint(5, 15))]
            pocket_residues[i + 1] = residues

        return {
            "status": "success",
            "pockets_dir": f"{output_dir}/pockets",
            "pocket_scores": pockets,
            "pocket_residues": pocket_residues,
            "runtime_sec": round(random.uniform(5, 30), 1),
        }


def get_mock_response(task_name: str, *args, **kwargs) -> Any:
    """
    Get mock response for a GPU task.

    Args:
        task_name: Name of the GPU task
        *args: Positional arguments for the task
        **kwargs: Keyword arguments for the task

    Returns:
        Mock response appropriate for the task
    """
    mock_functions = {
        "esmfold": MockGpuResponses.esmfold,
        "clean_ec": MockGpuResponses.clean_ec,
        "deepenzyme": MockGpuResponses.deepenzyme,
        "temberture": MockGpuResponses.temberture,
        "flan_extractor": MockGpuResponses.flan_extractor,
        "fpocket": MockGpuResponses.fpocket,
    }

    if task_name not in mock_functions:
        raise ValueError(f"Unknown task: {task_name}")

    return mock_functions[task_name](*args, **kwargs)


# Sample sequences for testing
SAMPLE_SEQUENCES = {
    "lysozyme": "MKTVRQERLKSIVRILERSKEPVSGAQLAEYLGDGTRIGGLSLWRDVTRQLLGPKNTSEYLADVITLAEQVERILGTDEVFVNAGRGRTHGGYVGALNYQDSQLTPQQNKLFAFDM",
    "insulin": "MALWMRLLPLLALLALWGPDPAAAFVNQHLCGSHLVEALYLVCGERGFFYTPKTRREAEDLQVGQVELGGGPGAGSLQPLALEGSLQKRGIVEQCCTSICSLYQLENYCN",
    "gfp": "MSKGEELFTGVVPILVELDGDVNGHKFSVSGEGEGDATYGKLTLKFICTTGKLPVPWPTLVTTLTYGVQCFSRYPDHMKQHDFFKSAMPEGYVQERTIFFKDDGNYKTRAEVKFEGDTLVNRIELKGIDFKEDGNILGHKLEYNYNSHNVYIMADKQKNGIKVNFKIRHNIEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSALSKDPNEKRDHMVLLEFVTAAGITLGMDELYK",
}

# Common ligand SMILES for testing
SAMPLE_LIGANDS = {
    "ATP": "C1=NC2=C(C(=N1)N)N=CN2C3C(C(C(O3)COP(=O)(O)OP(=O)(O)OP(=O)(O)O)O)O",
    "glucose": "OC[C@H]1OC(O)[C@H](O)[C@@H](O)[C@@H]1O",
    "NADH": "NC(=O)c1ccc[n+](C2OC(COP(=O)(O)OP(=O)(O)OCC3OC(n4cnc5c(N)ncnc54)C(O)C3O)C(O)C2O)c1",
}
